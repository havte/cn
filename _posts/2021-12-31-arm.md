---
title: 芯片设计之ARM64架构
layout: post
categories: 芯片
tags: ARM64 芯片架构
excerpt: ARMv8-A架构、ARM64架构介绍
---

## 1. ARM64架构介绍
## 1.1 ARMv8-A架构介绍
ARMv8-A是ARM公司发布的第一代支持64位处理器的指令集和架构。它在扩充64位寄存器的同时提供对上一代架构指令集的兼容，因而能同时提供运行32位和64位应用移序的执行环境。ARMv8-A架构除了提高了处理能力外，还引入了很多吸引人的新特性。

通过超大物理地址空间，提供超过4GB物理内存的访问。
具有64位宽的虚拟地址空间。32位处理器中只能提供4GB大小的虚拟地址空间，这极大限制了桌面系统和服务器等应用的发挥。64位宽的虚拟地址空间可以提供超大的访问空间。
提供31个64位宽的通用寄存器，可以减少对栈的访问，从而提高性能。
提供16KB和64KB的页面，有助于降低TLB的未命中率（miss rate）。
具有全新的异常处理模型，有助于降低操作系统和虚拟化的实现复杂度。
具有全新的加载-获取、存储-释放指令（load-acquire，store-release instruction），专为C++11、C11以及Java内存模型而设计。

## 1.2常见的ARMv8处理器
下面介绍市面上常见的ARMv8架构的处理器内核。

Cortex-A53处理器内核：ARM公司第一款采用ARMv8-A架构设计的处理器 内核，专为低功耗而设计，通常可以使用1~4个Cortex-A53处理器组成处理器簇（cluster），也可以和Cortex-A57/Cortex-A72等高性能处理器组成大小核架构。
Cortex-A57处理器内核：采用64位ARMv8-A架构设计的CPU，而且通过AArch32执行状态来保持与ARMv7架构的完全后向兼容性。除了ARMv8的架构优势之外，Cortex-A57还提高了单个时钟周期的性能，比高性能的Cortex-A15CPU高出20%~40%。CortexA57还改进了二级高速缓存的设计以及内存系统的其他组件，极大地提高了能效。
Cortex-A72处理器内核：2015年年初正式发布的基于ARMv8-A架构并对Cortex-A57处理器做了大量优化和改进的一款处理器内核。在相同的移动设备电池寿命限制下，Cortex-A72相比基于Cortex-A15的设备能提供3.5倍的性能提升，展现出优异的整体功耗效率。

## 1.3 ARM64的基本概念
ARM处理器实现的是精简指令集计算机（ReducedInstruction Set Computer，RISC）架构。本节介绍ARMv8-A架构中的一些基本概念。

处理单元
ARM公司的官方技术手册中提到了一个概念，可以把处理器处理事务的过程抽象为处理单元（Processing Element，（PE）。

执行状态
执行状态（execution state）是处理器运行时的环境，包括寄存器的位宽、支持的指令集异常模型、内存管理以及编程模型等。ARMv8架构定义了两种执行模式。

AArch64:64位的执行状态。提供31个64位的通用寄存器。提供64位的程序计数（PC）寄存器、栈指针（SP）寄存器以及异常链接寄存器（ELR）。提供A64指令集。定义ARMv8异常模型，支持4个异常等级ELO~EL3。提供64位的内存模型定义一组处理器状态（PSTATE）用来保存PE的状态。
AArch32:32位的执行状态。提供13个32位的通用寄存器，再加上PC寄存器、SP寄存器、链接寄存器（LR）。支持两套指令集，分别是A32和T32指令集（Thumb指令集）。支持ARMv7-A异常模型，基于PE模式并映射到ARMv8的异常模型。提供32位的虚拟内存访问机制。定义一组处理器状态（PSTATE）用来保存PE的状态。
ARMv8指令集
ARMv8架构根据不同的执行状态提供对不同指令集的支持。

A64指令集：运行在AArch64状态，提供64位指令集支持。
A32指令集：运行在AArch32状态，提供32位指令集支持。
T32指令集：运行在AArch32状态，提供16和32位指令集支持。
系统寄存器命名
在AArch64状态下，很多系统寄存器会根据不同的异常等级提供不同的变种寄存器

_ELx, where x is 0,1, 2, or 3

比如，SPELO表示ELO下的栈指针寄存器，SP_EL1表示EL1下的栈指针寄存器。

## 1.4ARMv8处理器的运行状态
ARMv8处理器支持两种运行状态--AArch64状态和AArch32状态。AArch64状态是ARMv8新增的64位运行状态，而AArch32状态是为了兼容ARMv7架构而保留的32位运行状态。当处理器运行在AArch64状态时执行A64指令集；而当运行在AArch32状态时，可以执行A32指令集或T32指令集。 AArch64架构的异常等级（exception level）确定了处理器当前运行的特权级别，类似于ARMv7架构中的特权等级.

EL0：用户特权，用于运行普通用户程序。
EL1：系统特权，通常用于运行操作系统。
EL2：运行虚拟化扩展的虚拟监控程序（hypervisor）。
EL3：运行安全世界中的安全监控器（secure monitor）.
在ARMv8架构里允许切换应用程序的运行模式。比如，在运行64位操作系统的ARMv8处理器中，我们可以同时运行A64指令集的应用程序和A32指令集的应用程序。但是在这行32位操作系统的ARMv8处理器中，就不能执行A64指令集的应用程序了。当需要执行 A32指令集的应用程序时，需要通过管理员调用（Supervisor Call, SVC）指令切换到EL1操作系统会执行任务的切换并且返回到AArch32的ELO，这时候系统便为这个应用程序备好了AArch32的运行环境。

## 1.5 ARMv8架构支持的数据宽度
ARMv8架构支持如下几种数据宽度。

字节（byte）：1字节等于8位。
半字（halfword）：16位。
字（word）：32位。
双字（doubleword）：64位。
4字（quadword）：128位。

## 1.6不对齐访问
不对齐访问有两种情况。一种是指令对齐，另一种是数据对齐。A64指令集要求指令存放的位置必须以字（word，32位宽）为单位对齐。访问存储位置不是以字为单位对齐的指令会导致PC对齐异常（PCaligment fault）。 对于数据访问，需要区分不同的内存类型。对内存类型是设备内存的不对齐访问会触发对齐异常（alignment fault）。 对于访问普通内存，除了使用独占。加载/独占-存储（load-exclusive/store-exclusive）指令或加载-获取/存储-释放（load-acquire/store-release）指令外，还可使用其他的用于加载或存储单个或多个寄存器的所有指令。如果访问地址和要访问的数据元素大小不对齐，那么可以根据以下两种情况进行处理:

若对应的异常等级中的SCTLR_ELx寄存器的A域设置为1，则说明打开了地址对齐检查功能，因而会触发对齐异常。

若对应的异常等级中的SCTLRELx寄存器的A域设置为0，则说明处理器支持不对齐访问。 当然，处理器支持的不对齐访问也有一些限制。

不能保证单次访问原子地完成，有可能复制多次。

不对齐访问比对齐访问需要更多的处理时间。

不对齐的地址访问可能会引发中止（abort）。
